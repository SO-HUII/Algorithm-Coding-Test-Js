## ✍🏻 제목 : 최대부분 증가수열
N개의 자연수로 이루어진 수열이 주어졌을 때, 그 중에서 가장 길게 증가하는(작은 수에서 큰 수로) 원소들의 집합을 찾는 프로그램을 작성하라. 

예를 들어, 원소가 2, 7, 5, 8, 6, 4, 7, 12, 3 이면 가장 길게 증가하도록 원소들을 차례대로 뽑아내면 2, 5, 6, 7, 12를 뽑아내어 길이가 5인 최대 부분 증가수열을 만들 수 있다.

- `입력조건` : N개의 입력데이터들이 주어진다.

- `출력조건` : 첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.

|입력예시|출력예시|
|:------:|:----:|
|5 3 7 8 6 2 9 4|4|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
dy[0] = 1;

for(let i = 1; i < arr.length; i++) {
    let max = 0;
    for(let j = i - 1; j >= 0; j--) {
        // 조건 1. j 인덱스의 값이 i 인덱스의 값보다 작을 시 (i인덱스 값 앞에 위치할 수 있기 때문)
        // 작은 수가 1개 이상이면, 현재 최댓값보다 큰 수일 시
        if(arr[j] < arr[i] && dy[j] > max) {
            max = dy[j];
        }
    }
    dy[i] = max + 1;
    answer = Math.max(answer, dy[i]);
}
```

dy에는 해당 인덱스의 `arr` 배열의 인덱스 값까지의 최대부분 증가수열의 길이를 저장한다.
`arr[0]` 앞에 원소가 존재하지 않기 때문에 증가 수열에 자기 자신만 포함하므로 `dy[0]`을 1로 초기화

이중 반복문에서 지정되어 있는 수열을 유지하며 최대부분 증가수열을 구해야하기 때문에 현재 항 앞의 항들만 탐색하고 포함할 수 있다.
앞에 존재하는 원소 중 arr[i]보다 작으면서 부분 증가 수열의 길이가 가장 긴 길이에 1(자기 자신 포함)을 더한 값을 dy[i]에 저장하며 마지막 배열까지 탐색하여 준다.

</br>

---

### 🎉 새로 알게된 점은?


</br>

---

### 🐾 회고