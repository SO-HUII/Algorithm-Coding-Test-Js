## ✍🏻 제목 : 두 배열 합치기
오름차순으로 정렬이 된 두 배열이 주어지면 두 배열을 오름차순으로 합쳐 출력하는 프로그램을 작성하세요.

- `입력조건` : 첫 번째 줄에 첫 번째 배열의 크기 N(1<=N<=100)이 주어집니다.
두 번째 줄에 N개의 배열 원소가 오름차순으로 주어집니다. 
세 번째 줄에 두 번째 배열의 크기 M(1<=M<=100)이 주어집니다.
네 번째 줄에 M개의 배열 원소가 오름차순으로 주어집니다. 
각 리스트의 원소는 int형 변수의 크기를 넘지 않습니다.


- `출력조건` : 오름차순으로 정렬된 배열을 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|3</br>1 3 5</br>5</br>2 3 6 7 9|1 2 3 3 5 6 7 9|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
for(let i = 0; i < numArr2.length; i++) {
        numArr1.push(numArr2[i]);
    }

    answer = numArr1.sort((a, b) => a - b).join(' ');
```
한 배열에 남은 배열의 원소를 `push()`를 이용해 넣어주고 합쳐진 배열을 다시 `sort()`를 이용해 오름차순 정렬해준다.
```javascript
let answer = [];
// 투포인터 p1, p2 0으로 초기화
let p1 = p2 = 0;

// 둘 중 한 배열이 더 짧아 반복이 먼저 끝난다면 그걸로 반복 종료 
while(p1 < numArr1.length && p2 < numArr2.length) {
    // 오름차순 정렬이기 때문에 작다면 answer에 넣어줌.
    // 그리고 넣어준 수의 인덱스를 1 증가 시켜 오른쪽으로 포인터를 옮겨줌.
    if(numArr1[p1] <= numArr2[p2]) answer.push(numArr1[p1++]);
    else answer.push(numArr2[p2++]);
}

// numArr1이 배열끝까지 반복되지 않고 남았다면 남은 수를 순차적으로 answer에 추가 (어차피 이미 배열이 오름차순으로 되어있긴 때문에 그대로 넣어줘도 무방)
while(p1 < numArr1.length) answer.push(numArr1[p1++]);
while(p2 < numArr2.length) answer.push(numArr2[p2++]);
```
해당 문제는 **투포인터**로 해결할 수도 있다. 우선 **포인터**로 쓸 두 개의 `p1`, `p2`를 `0`으로 초기화해준다. `while`문을 이용하여 둘 중 한 배열의 포인터가 배열의 길이보다 짧아진다면(=**배열의 반복이 끝**난다면) while을 탈출한다. 그렇지 않다면 두 개의 포인터를 인덱스 삼아 두 배열을 **비교**한 뒤 **다른 배열보다 작거나 같은** 배열을 `answer`에 `push()`해 넣어준다. 그리고 후위연산자를 이용하여 해당 배열의 **포인터를 1증가** 시켜주어 포인터의 위치를 오른쪽으로 한 칸 이동 시켜준다(인덱스 +1).

다음으로, 둘 중 한 배열이 짧아 **반복문을 탈출**한다면 다른 배열의 **남은 요소**들을 순차적으로 `answer`에 넣어준다. 이때 그냥 순서대로 넣어줘도 되는 이유는 이미 남은 배열의 요소들은 오름차순 정렬되어 있는 상태이고 answer의 요소들도 남은 배열 안의 요소보다 작거나 같은 값으로 오름차순 정렬되어 있기 때문이다. 
</br>

---

### 🎉 새로 알게된 점은?
투포인터를 사용한다면 이중 루프를 이용해 시간 복잡도 면에서나 공간 복잡도 면에서 효율이 떨어지는 해결방식을 사용하지 않고 좀 더 효율적인 방법으로 문제를 해결할 수 있다는 것을 알게 되었다. 지금은 배열의 크기가 작으니 크게 차이가 나지는 않지만 그 크기가 커질 수록 속도 면에서 기하급수적으로 차이가 벌어질 것 이라는 것이 투포인터를 사용하게 되는 이유일 것이다.

주로 연속되는 수들의 합이나 부분 배열의 합에서 많이 사용되는 것 같다.

</br>

---

### 🐾 회고
투포인터라는 개념을 처음 알게되었는데 단순 반복문으로 처리할 수 있는 부분을 여러 포인터를 이용해 탐색하는 과정이 재미있었다. 