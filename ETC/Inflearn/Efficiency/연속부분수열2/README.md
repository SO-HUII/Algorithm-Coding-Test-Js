## ✍🏻 제목 : 연속부분수열2
N개의 수로 이루어진 수열이 주어집니다. 이 수열에서 연속부분수열의 합이 특정숫자 M이하가 되는 경우가 몇 번 있는지 구하는 프로그램을 작성하세요.

만약 N = 5, M = 5이고 수열이 다음과 같다면

1 3 1 2 3

합이 5이하가 되는 연속부분수열은 {1}, {3}, {1}, {2}, {3}, {1, 3}, {3, 1}, {1, 2}, {2, 3}, {1, 3, 1}로 총 10가지입니다.


- `입력조건` : 첫째 줄에 N(1≤N≤100,000), M(1≤M≤100,000,000)이 주어진다. 
수열의 원소값은 1,000을 넘지 않는 자연수이다.

- `출력조건` : 첫째 줄에 경우의 수를 출력한다.

|입력예시|출력예시|
|:------:|:----:|
|5 5|1 3 1 2 3|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
for(let rp = 0; rp < numArr.length; rp++) {
        sum += numArr[rp];
        
        while(sum > num) {
            sum -= numArr[lp++];
        }
        count += (rp - lp + 1);
    }
```
포인터 `rp`, `lp`를 이용하여 문제를 해결해보자. `rp`는 반복문이 한 번 끝날 때마다 **오른쪽으로 이동**하여 수를 탐색해나간다. `sum`은 부분 수열이 `num` 이하가 되는지 판별할 때 쓰인다. 만약 `sum`이 `num`보다 **커진다**면 부분 수열 또한 5이하가 아닐 수 있기에 `sum`에서 현재 `lp`가 가리키는 위치의 수를 **빼주고** `lp`의 위치를 **오른쪽으로 이동**시켜 **새로운 부분 수열을 탐색**할 수 있도록한다. 반복문을 탈출한다면 `sum`이 `num` 이하이고 부분수열 또한 5 이하인 것이므로 해당 탐색 지점까지의 부분 수열(`rp - lp + 1`)을 `count`에 넣어준다. 

부분 수열의 개수를 rp - lp + 1로 count 해주는 까닭은 예를 들어 현재 `lp`가 가리키는 위치의 숫자는 `1` (numArr[0]) 이고 `rp`는 numArr[1]로 `3`을 가리킨다면 부분 수열은 **{1}, {3}, {1, 3}**이다. 즉, rp(==1) - lp(==0) + 1 = 2개이다. 왜 3이 아니냐면 **{1}**은 이미 `rp`와 `lp`가 `0`일때 세어주었기 때문이다.

</br>

---

### 🐾 회고
부분 수열의 수를 세는 규칙과 같이 공통적인 규칙을 잘 찾을 수 있고 그것을 식으로 만들어 이용해야 하는데 그런 통찰력이 아직 너무 부족한 것 같다. 이게 너무 스트레스고 고민이어서 챗지피티 선생님께 고민상담을 했더니 조언으로 많은 말을 해주셨는데 그 중 나에게 맞을 것 같은 내용을 가져와봤다.
1. 작은 입력 값이나 특이한 입력에 대해 문제를 해결하는 방법을 고민해보면 핵심 아이디어를 도출할 수 있다.
2. 문제를 작은 단위로 분해하고 각각의 부분 문제에 집중하라. 큰 문제를 해결하기 위해 작은 단위의 문제들을 해결하는 접근법은 복잡한 문제를 해결하는 데 도움이 된다.

외에도 문제를 천천히 읽고 시간 투자를 많이 하라는 내용이 있었는데 나는 문제를 오래 보면 볼수록 머릿속에서 엉키고 집중력이 떨어지는 느낌이 있어서 지금보다 조금만 더 문제를 읽는데 투자하기로 타협했다. 사실 내가 문제를 많이 푼 것도 아니고 (그러고 보니 아직 40문제정도 밖에 안 푼듯..?) 그런 시점에서 울상짓기엔 이른 시점이라는 것을 잘안다. 그래도 사람 마음이 마음대로 안된다 참나~