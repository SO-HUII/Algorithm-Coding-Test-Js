## ✍🏻 제목 : 공통원소 구하기 
A, B 두 개의 집합이 주어지면 두 집합의 공통 원소를 추출하여 오름차순으로 출력하는 프로그램을 작성하세요.

- `입력조건` : 첫 번째 줄에 집합 A의 크기 N(1<=N<=30,000)이 주어집니다.
두 번째 줄에 N개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
세 번째 줄에 집합 B의 크기 M(1<=M<=30,000)이 주어집니다.
네 번째 줄에 M개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
각 집합의 원소는 1,000,000,000이하의 자연수입니다.


- `출력조건` : 두 집합의 공통원소를 오름차순 정렬하여 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|5</br>1 3 9 5 2</br>5</br>3 2 5 7 8|2 3 5|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
for(let i = 0; i < numArr1.length; i++) {
        for(let j = 0; j < numArr2.length; j++) {
            if(numArr1[i] == numArr2[j]) {
                if(!answer.includes(numArr1[i])) {
                    answer.push(numArr1[i]);
                }
            }
        }
    }
    return answer.sort().join(' ');
```
중첩 반복문을 이용하여 배열을 탐색하며 두 배열의 요소가 같다면 `answer`에 추가해준다. 중복되는 수가 없어야하기에 `includes()`로 해당 수가 이미 `answer`에 포함되어있는지를 판별해준다.

```javascript
// sort() 사용시 숫자가 두자리수 이상이라면 1, 10, 2, .. 이런식(사전순)으로 정렬될 수 있음
// numArr1.sort();  
// numArr2.sort();

// 저런 일을 방지하기 위해 콜백 함수를 이용해 정렬 기준을 주면 숫자 정렬이 된다.
numArr1.sort((a, b) => a - b);  
numArr2.sort((a, b) => a - b);

let p1 = p2 = 0;

while(p1 < numArr1.length && p2 < numArr2.length) {
    if(numArr1[p1] == numArr2[p2]) {
        answer.push(numArr1[p1++]);
        p2++;
    } else if(numArr1[p1] < numArr2[p2]) p1++;
    else p2++;
}
```
이 문제는 효율성을 위해 **투포인터**를 이용하는 방법이 더 현명하다. 시간복잡도가 확연히 줄기 때문이다. `numArr1[p1]`와 `numArr2[p2]`의 값이 같다면 어차피 둘다 같은 값이니 배열의 값 중 하나를 answer에 넣어주고 두 배열을 가리키는 포인터를 다 증가시켜준다. 만약 둘 중 하나가 작다면 작은 수의 포인터를 증가시켜주어 포인터의 위치를 오른쪽으로 이동시킨다. 

작은 값을 먼저 증가시키는 이유는 배열이 둘다 오름차순으로 정렬되어있기 때문에 작은 값은 포인터를 증가시켜도 뒤에 큰 값과 같은 값이 있을 수도 있지만 큰 값의 뒤에는 현재 비교한 값과 같은 작은 값이 있을리 없기 때문이다.
</br>

---

### 🎉 새로 알게된 점은?
sort()에 대해서 다 알고 있다고 생각했는데 오만한 생각이었다. sort() 사용시 수가 문자열로 바뀌어 사전 순의 오름차순으로 나열된다는 사실을 모르고 있어서 자칫하면 두자릿수 이상일때 엉뚱한 답을 내놓을 뻔 했다. 테스트 배열을 전부 한 자리수로 설정해놓아 이런 실수를 모르고 넘어갈 뻔 하였다.

</br>

---

### 🐾 회고
오만하지 말자. 잘 알고 있다고 생각한 것도 MDN 문서 등에서 다시 한 번 찾아보아야 겠다. 운전도 가장 자신이 잘하고 있다고 할 때 사고가 난다더니 딱 그 격이었다 ..ㅎㅎㅎ