## ✍🏻 제목 : 최대점수 구하기
이번 정보올림피아드대회에서 좋은 성적을 내기 위하여 현수는 선생님이 주신 N개의 문제를 풀려고 합니다. 각 문제는 그것을 풀었을 때 얻는 점수와 푸는데 걸리는 시간이 주어지게 됩니다. 제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 해야 합니다. (해당 문제는 해당 시간이 걸리면 푸는 걸로 간주한다. 한 유형당 한개만 풀 수 있다.)

- `입력조건` : 첫 번째 줄에 문제의 개수N(1<=N<=20)과 제한 시간 M(10<=M<=300)이 주어집니다. 두 번째 줄부터 N줄에 걸쳐 문제를 풀었을 때의 점수와 푸는데 걸리는 시간이 주어집니다.

- `출력조건` : 첫 번째 줄에 제한 시간안에 얻을 수 있는 최대 점수를 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|5 20</br>10 5</br>25 12</br>15 8</br>6 3</br>7 4|41|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
function solution(limitT, queArr) {
    let answer = Number.MIN_SAFE_INTEGER;

    function DFS(L, sumS, sumT) {
        if(sumT > limitT) return;
        if(L == queArr.length) {
            answer = Math.max(answer, sumS);
        } else {
            DFS(L + 1, sumS + queArr[L][0], sumT + queArr[L][1]);
            DFS(L + 1, sumS, sumT);
        }
    }
    DFS(0, 0, 0)
    return answer;
}
```

</br>

---

### 🎉 새로 알게된 점은?
n의 개수가 해당 문제처럼 작지 않고 크다면 시간 복잡도 면에서 좋지 않기 때문에 그런 경우에는 **Dynamic programming(동적 계획법)** 으로 푸는 방법이 좋을 듯 싶다.
동적 계획법은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다.

특징으로, 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다. 구현은 일반적으로 두 가지 방식(**탑다운과 보텀업**)으로 구성된다. ( 탑다운: 하향식, 보텀업: 상향식 )

또한 아래 두 가지 조건이 만족될 때 사용할 수 있다.

1. **최적 부분 구조 (Optimal Substructure)**
큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
2. **중복되는 부분 문제 (Overlapping Subproblem)**
동일한 작은 문제를 반복적으로 해결해야 합니다.