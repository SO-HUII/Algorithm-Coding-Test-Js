## ✍🏻 제목 : 가장 짧은 문자거리
한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출
력하는 프로그램을 작성하세요. 
- `입력조건` : 첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다.
문자열의 길이는 100을 넘지 않는다.

- `출력조건` : 첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.

|입력예시|출력예시|
|:------:|:----:|
|teachermode e|1 0 1 2 1 0 1 2 2 1 0|


</br>

---

### 🔍 이렇게 접근 했어요 !
이 문제는 앞부터 순차적으로 자신보다 왼쪽에 있는 e와 떨어진 거리를 구해주고 오른쪽에 위치한 e와 더 가까울 수 있으니 맨 뒤에서부터 처음까지 한 번 더 탐색하여 둘 중 더 가까운 위치를 고르며 문제를 해결해야한다.

```javascript
let min = Number.MAX_SAFE_INTEGER;

    // 앞 -> 뒤 (자신보다 왼쪽에 있는 e와 떨어진 거리)
    for(let i = 0; i < str.length; i++) {
        if(str[i] == ch) min = 0;
        else min++;
        answer.push(min);
    }
```
먼저 앞에서 뒤로, 자신보다 왼쪽에 있는 e와 떨어진 거리를 구해준다. 탐색 문자열의 문자가 입력한 문자(여기서는 e)와 같으면 거리를 저장하는 변수인 min을 0으로 초기화해준다. 본인과 본인이 떨어진 거리는 0이니까! 만약 입력한 문자가 아니라면 min을 1증가 시켜준다. 조건문 탐색이 끝나면 해당 거리 변수를 배열 answer에 push()를 이용해 넣어준다.

```javascript
min = Number.MAX_SAFE_INTEGER; 
    // 뒤 -> 앞 (자신보다 오른쪽에 있는 e와 떨어진 거리)
    for(let i = str.length - 1; i >= 0; i--) {
        if(str[i] == ch) min = 0;
        else min++;

        if(min < answer[i]) {
            answer[i] = min;
        }
    }
    return answer.join(' ');
```
다음으로는 뒤에서 앞까지, 자신보다 오른쪽에 있는 e와 떨어진 거리를 구해주어야 한다. 먼저 min을 다시 큰 수로 초기화해준다. 앞으로 차례대로 반복문을 진행하며 거리를 판단해주고 다만 여기서는 이미 처음부터 끝까지 탐색한 거리값을 넣은 answer 배열의 값들과 최소 거리를 비교해주어야 한다. 비교하여 더 작은 값이 answer에 남게된다. 

추가로 join() 메서드를 이용하여 배열을 문자열로 바꾸어주었고 , 표시도 없애주었다.

</br>

---

### 🎉 새로 알게된 점은?
반복문을 반대 방향으로 돌며 나온 값들을 빼주면 되지 않을까 생각했는데 어떤 배열을 피감수나 감수로 해야할지 기준이 애매했다. 그리고 음수를 제거한다고 해도 원하는 값이랑 전혀 다른 값이 나오니 결과적으로는 잘못된 해결방안이었다. 탐색하는 것의 방향을 잘 모른채로 코드를 구상하려고 해서 그런 것 같다. 앞 -> 뒤 탐색은 자신보다 왼쪽, 뒤 -> 앞 탐색은 자신보다 오른쪽의 있는 문자를 기준으로 한다는 사실을 잘 인지하지 못하였다. 이번 문제를 풀며 그 점을 확실히 이해할 수 있었다. 

</br>

---

### 🐾 회고
다음부터는 알고리즘 구현 전 문제를 보고 파악한다음 순서도를 그려가면서 하는 습관을 들여야할 것 같다. 연필로 쓰거나 그리면서 하는 것이 훨씬 도움이 되는 것 같다. 하루종일 키보드를 만지다가 연필을 잡으면 리프레쉬가 되는 느낌이랄까?