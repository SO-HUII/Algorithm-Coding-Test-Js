## ✍🏻 제목 : 버블 정렬
N개이 숫자가 입력되면 오름차순으로 정렬하여 출력하는 프로그램을 작성하세요. 정렬하는 방법은 버블정렬입니다.

- `입력조건` : 첫 번째 줄에 자연수 N(1<=N<=100)이 주어집니다. 두 번째 줄에 N개의 자연수가 공백을 사이에 두고 입력됩니다. 각 자연수는 정수형 범위 안에 있습니다.

- `출력조건` : 오름차순으로 정렬된 수열을 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|6</br>13 5 11 7 23 15|5 7 11 13 15 23|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
for(let i = 0; i < numArr.length - 1; i++) {
    // i for문이 끝날 때마다 가장 큰 수는 뒤로 배치가 고정되기 때문에 
    // 다음 i for문을 돌 때 굳이 그 위치까지 반복문을 수행할 필요가 없다. 
    for(let j = 0; j < numArr.length - i - 1; j++) {
        if(numArr[j + 1] < numArr[j]) {
            [numArr[j], numArr[j + 1]] = [numArr[j + 1], numArr[j]]; 
        }        
    }
}
```
버블 정렬은 선택정렬과 달리 `i for`문이 한 번 끝나면 가장 큰 수 부터 맨 뒤에 위치하기 때문에 그 수는 **이미 정렬**되었다고 볼 수 있다.
그러므로 다시 정렬을 수행한다고 하더라도 위치에 변화가 없고 반복문이 완전히 끝날 때까지 그자리에 **고정**되어 있기 때문에 해당 위치까지 반복문을 수행할 필요가 없어진다.
그러므로 `j for`문의 반복 범위를 `numArr.length - i - 1` 해주어 i for이 수행될 수록 범위를 줄여나갔다.

`i for`문의 반복 범위가 `numArr.length - 1`인 이유는 배열의 길이보다 1 적은 수만큼의 범위로 반복문을 수행하고 나면 이미 모든 배열의 요소가 정렬이 되어 그 다음 반복을 수행할 필요가 없기 때문이다.

</br>

---

### 🎉 새로 알게된 점은?
버블 정렬은 서로 인접한 두 요소를 비교하는 것이다. 다른 곳에 위치한 요소가 더 작거나 크거나 등등 하다고 해서 위치를 바꾸는 것이 아니라 인접해있는 요소로 비교할 수 있다. 그렇기 때문에 반복되는 탐색이 많아 효율적인 면에서 떨어질 수 있다. 

공부하며 의문이 들었던 점이 버블 정렬이 그렇게 비효율적이고 필요한 경우가 손에 꼽기도 힘든 알고리즘이라면 왜 정렬 알고리즘을 학습할 때 빠지지 않고 등장하는지 였다. 

학습의 측면에서는 난이도 배치를 위해 처음에는 이해도, 구현도 간단한 버블 정렬으로 학습자들을 환기시키고 적응시키는 게 목적이지 않나 싶다. 순전히 내 추측이지만. 또한 나같은 의문을 가진 사람 있을까 해서 2005년도 커뮤니티 자료까지 뒤져보았는데 의견이 정말 많았다.

어떤 사람은 '알고리즘은 어떤것이 가장 좋다는 생각은 좋지 않으며 어떠한 환경에서 어떤 알고리즘이 가장 좋을까를 생각해야 한다. 그리고 한가지 알고리즘으로 해결하기보단 두,세가지의 알고리즘을 써야할 때도 있다.' 라고 하였다. 또한 버블 정렬이 항상 다른 알고리즘보다 유달리 비효율적인 것도 아닌듯 싶다. 특정 상황에서는 버블 정렬을 사용하는 것이 더 빠른 면도 있는 것 같다.

</br>

---

### 🐾 회고
공부를 하다보면 문득문득 정말 뜬금없는 것이 궁금할 때가 있는데 시간이 없다, 가치가 없는 의문인 것 같다고 그동안 생각해오며 검색하기를 거려했지만 최근에는 정말 사소하거나 알 필요 없을 것 같은 유래도 찾아보고 있다. 머리를 환기해주기도 하지만 그런 것들에서 의미있는 무언가를 발견해내기도 하는 날이 늘고 있기 때문...