## ✍🏻 제목 : 장난꾸러기 현수
새 학기가 시작되었습니다. 현수는 새 짝꿍을 만나 너무 신이 났습니다. 현수네 반에는 N명의 학생들이 있습니다. 선생님은 반 학생들에게 반 번호를 정해 주기 위해 운동장에 반 학생들을 키가 가장 작은 학생부터 일렬로 키순으로 세웠습니다. 제일 앞에 가장 작은 학생부터 반 번호를 1번부터 N번까지 부여합니다. 현수는 짝꿍보다 키가 큽니다. 그런데 현수가 앞 번호를 받고 싶어 짝꿍과 자리를 바꿨습니다. 선생님은 이 사실을 모르고 학생들에게 서있는 순서대로 번호를 부여했습니다. 

현수와 짝꿍이 자리를 바꾼 반 학생들의 일렬로 서있는 키 정보가 주어질 때 현수가 받은 번호와 현수 짝꿍이 받은 번호를 차례로 출력하는 프로그램을 작성하세요.

- `입력조건` : 첫 번째 줄에 자연수 N(5<=N<=100)이 주어진다. 두 번째 줄에 제일 앞에부터 일렬로 서있는 학생들의 키가 주어진다. 키(높이) 값 H는 (120<=H<=180)의 자연수입니다.

- `출력조건` : 첫 번째 줄에 현수의 반 번호와 짝꿍의 반 번호를 차례로 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|9</br>120 125 152 130 135 135 143 127 160|3 8|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
let sortArr = heightArr.slice();
sortArr.sort((a, b) =>  a - b);

for(let i = 0; i < heightArr.length; i++) {
    if(heightArr[i] != sortArr[i]) answer.push(i + 1);  // 순서이기 때문에 0이 아닌 1부터 세어주기 때문에 +1
}
```
현수와 짝꿍이 자리를 바꾼 후 줄의 배열을 heightArr라고 했을 때 현수와 짝꿍이 자리를 바꾼 위치가 어디인지 알고 싶다면 heightArr을 오름차순으로 바르게 정렬하여 같은 인덱스의 수가 같은지 비교하여 주면 된다. slice() 메소드를 사용하여 배열을 얕은 복사하여 원본 배열에 영향이 미치지 않도록 한다. 배열을 정렬하기 위한 방법으로는 sort()를 사용하면 오름차순 정렬이 되는데 sort()는 문자열 기반의 정렬 방식이기 때문에 수를 정렬할 때 예상치 못 한 실수를 범할 수 있다. 예를 들어 123, 99, 230을 sort()으로 정렬한다면 우리가 기대하는 값은 99, 123, 230이지만 실제로는 123, 230, 99의 문자열 기반 오름차순 정렬이 되는 것을 볼 수 있다. 그렇기 때문에 sort()로 숫자를 정렬하기 위해서는 callback 함수((a, b) =>  a - b)를 사용하여 a - b 시 0 이상이 나올 때, a가 b보다 크다는 의미이므로 a가 b보다 뒤에 위치하여 정렬된다.

배열의 길이만큼 반복문을 돌며 heightArr[i]과 sortArr[i]이 같지 않다면 그곳의 인덱스가 현수와 짝꿍이 자리를 바꾼 위치이므로 해당 인덱스를 저장한다.  

</br>

---

### 🐾 회고
sort()를 이용한 수의 정렬 시 callback 함수를 사용해주어야 하는 것을 잊을 뻔 했다. 사람의 기억은 왜 이렇게 한정적일까? 돌아서며 잊게 되는 것 같아서 슬프기도 하다.. 하긴 좋아하는 노래 가사도 외우려면 20번 정도는 들어야 조금이나마 완벽하게 외워지는데 sort()를 사용하는 문제를 내가 20개 이상 풀었던가? 아닌 것 같다. 그럼 슬퍼하기는 이르군! 다시 빠샤빠샤다!!