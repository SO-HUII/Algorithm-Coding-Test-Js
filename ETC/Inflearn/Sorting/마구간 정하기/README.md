## ✍🏻 제목 : 마구간 정하기
N개의 마구간이 수직선상에 있습니다. 각 마구간은 x1, x2, x3, ..., xN의 좌표를 가지며, 마구간에 좌표가 중복되는 일은 없습니다. 현수는 C마리의 말을 가지고 있는데, 이 말들은 서로 가까이 있는 것을 좋아하지 않습니다. 각 마구간에는 한 마리의 말만 넣을 수 있고, 가장 가까운 두 말의 거리가 최대가 되게 말을 마구간에 배치하고 싶습니다. 

C마리의 말을 N개의 마구간에 배치했을 때 가장 가까운 두 말의 거리가 최대가 되는 그 최대값을 출력하는 프로그램을 작성하세요.

- `입력조건` : 첫 줄에 자연수 N(3 <= N <= 200,000)과 C(2 <= C <= N)이 공백을 사이에 두고 주어집니다. 둘째 줄에 마구간의 좌표 xi(0 <= xi <= 1,000,000,000)가 차례로 주어집니다.

- `출력조건` : 첫 줄에 가장 가까운 두 말의 최대 거리를 출력하세요.

|입력예시|출력예시|
|:------:|:----:|
|5 3</br>1 2 8 4 9|3|

</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
// 배치할 수 있는 말의 수를 return하는 함수
function count(stallArr, distance) {
    // 한 마리는 무조건 배치
    let cnt = 1;
    // point: 직전 말을 배치한 위치
    let point = stallArr[0];

    // 해당 지점에 말을 배치할 수 있는지 없는지 stallArr의 원소를 모두 탐색하며 검사
    for(let i = 1; i < stallArr.length; i++) {
        if(stallArr[i] - point >= distance) {
            cnt++;
            // 해당 지점에 말 배치
            point = stallArr[i];
        }
    }
    return cnt;
}
```
수직선상 마구간에 배치할 수 있는 말의 수를 반환하는 count 함수이다. 우선 한 마리는 처음에 무조건 배치해야하기 때문에 `point`를 말들의 위치를 담고 있는 `stallArr`배열의 첫 번째 위치로 초기화해준다. `stallArr`을 반복하며 첫 번째 위치 다음 위치부터 탐색한다. 만약 `stallArr[i]`위치에서 그 전에 저장한 말의 위치의 거리를 뺐을때 그 거리가 **가장 가까운 두 말의 최대 거리**가 될 수 있는 `distance`보다 크거나 같다면 말이 현재 `stallArr[i]`위치에 배치될 수 있는 것이므로 배치할 수 있는 말의 수를 세는 cnt 변수를 +1 증가 시키고 `point`는 현재 위치로 초기화하여 다음 위치와 비교할 수 있도록 해준다.

```javascript
function solution(horse, stallArr) {
    let answer;
    stallArr.sort((a, b) => a - b);
    let lt = 1;
    // stallArr 배열의 마지막 원소
    let rt = stallArr[stallArr.length - 1];

    while(lt <= rt) {
        // mid: 가장 가까운 말의 거리 
        let mid = parseInt((lt + rt) / 2);

        if(count(stallArr, mid) >= horse) {
            answer = mid;
            lt = mid + 1;
        } else rt = mid - 1;
    }
    return answer;
}
```
`stallArr`배열을 오름차순 정렬한다. sort()만 사용할 경우 문자열 오름차순 정렬이니 꼭! 화살표 함수를 사용해서 숫자 오름차순 정렬으로 만들어준다. 마굿간의 최소 거리를 lt, 1로 초기화 시켜주고 최대 거리 rt는 배열의 마지막 원소보다 거리가 멀 수는 없으니 마지막 원소로 초기화 시켜준다. 조건이 false(lt > rt)일 시까지 반복문을 돌며 count()함수를 사용해 만약 반환값이 horse, 즉 설정한 말의 수보다 크다면 answer에 mid를 저장한다. 그렇지 않다면(작다면) rt를 mid - 1로 초기화하여 다시 탐색해준다.

1. 1, 2, 4, 8, 9가 입력되었고, 수직선상이니 좌표가 필요 => 오름차순 정렬
2. 최솟값이 1, 최댓값이 9이므로 말의 최대 거리는 1 ~ 9 사이 존재
3. `mid = (rt - lt) / 2 = 5` => 가까운 두 말의 최대 거리 = 5
4. 두 말의 거리가 5 이상인 말이 총 몇 마리 있는지 count
5. 1번 마구간에 말은 이미 존재. `stallArr[i] - point >= distance` 
=> 1, 2 의거리는 1 이므로 5이상이 아님.
   1, 4 의 거리는 3 이므로 5이상이 아님.
   1, 8 의 거리는 7 이므로 5이상. => cnt++
   8, 9 의 거리는 1 이므로 5이상이 아님.

세 마리의 말이 마구간에 들어가야 하는데 1번, 8번 마구간, 두 마리의 말만 할당됨.
그러므로 `rt = mid - 1` 정답은 1 ~ 4 사이에 존재. 다시 위의 내용을 반복해준다.
