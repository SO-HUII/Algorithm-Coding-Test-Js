## ✍🏻 제목 : Least Recently Used
캐시메모리는 CPU와 주기억장치(DRAM) 사이의 고속의 임시 메모리로서 CPU가 처리할 작업을 저장해 놓았다가 필요할 바로 사용해서 처리속도를 높이는 장치이다. 
워낙 비싸고 용량이 작아 효율적으로 사용해야 한다. 철수의 컴퓨터는 캐시메모리 사용 규칙이 LRU 알고리즘을 따른다. LRU 알고리즘은 Least Recently Used 의 약자로 직역하자면 가장 최근에 사용되지 않은 것 정도의 의미를 가지고 있습니다. 캐시에서 작업을 제거할 때 가장 오랫동안 사용하지 않은 것을 제거하겠다는 알고리즘입니다. 

만약 캐시의 사이즈가 5이고 작업이 
2 3 1 6 7 순으로 저장되어 있다면, (맨 앞이 가장 최근에 쓰인 작업이고, 맨 뒤는 가장 오랫동안 쓰이지 않은 작업이다.)

1) Cache Miss : 해야할 작업이 캐시에 없는 상태로 위 상태에서 만약 새로운 작업인 5번 작업을 CPU가 사용한다면 Cache miss가 되고 모든 작업이 뒤로 밀리고 5번작업은 캐시의 맨 앞에 위치한다. 
5 2 3 1 6 (7번 작업은 캐시에서 삭제된다.)

2) Cache Hit : 해야할 작업이 캐시에 있는 상태로 위 상태에서 만약 3번 작업을 CPU가 사용한다면 Cache Hit가 되고, 63번 앞에 있는 5, 2번 작업은 한 칸 뒤로 밀리고, 3번이 맨 앞으로 위치하게 된다. 

5 2 3 1 6 ---> 3 5 2 1 6

캐시의 크기가 주어지고, 캐시가 비어있는 상태에서 N개의 작업을 CPU가 차례로 처리한다면 
N개의 작업을 처리한 후 캐시메모리의 상태를 가장 최근 사용된 작업부터 차례대로 출력하는 
프로그램을 작성하세요.


- `입력조건` : 첫 번째 줄에 캐시의 크기인 S(3 <= S <= 10)와 작업의 개수 N (5 <= N <= 1,000)이 입력된다. 두 번째 줄에 N개의 작업번호가 처리순으로 주어진다. 작업번호는 1 ~ 100 이다.

- `출력조건` : 마지막 작업 후 캐시메모리의 상태를 가장 최근 사용된 작업부터 차례로 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|5 9</br>1 2 3 2 6 2 3 5 7|7 5 3 2 6|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
let cache = Array.from({length: cacheSize}, () => 0);

workArr.forEach(x => {
    let pos = -1;  // let pos = answer.indexOf(x) 내장 함수 사용해도 무관.
    for(let i = 0; i < cacheSize; i++) {
        // Cache Hit
        if(x == cache[i]) pos = i;
    }
    // Cache Miss면 pos = -1 
    if(pos == -1) {
        for(let i = cacheSize - 1; i >= 1; i--) {
            // Cache Miss일 시 앞에 새로운 작업 추가 후 원래 값들은 뒤로 한 칸씩 밀려남
            cache[i] = cache[i - 1];
        }
    } else {
        // Cache Hit
        // Hit 발생 시점부터 반복문 시작
        for(let i = pos; i >= 1; i--) {
            cache[i] = cache[i - 1];
        }
    }
    cache[0] = x;
});
```
1. `Array.from`을 이용해 `cacheSize` 만큼의 길이를 가진 배열 `cache`를 만들어 cacheSize만큼 `0`을 채워넣어준다. 
2. forEach를 이용해 `workArr` 배열의 요소를 차례로 탐색한다. 우선, **인덱스를 저장**하는 `pos` 변수를 만들고 cacheSize(cache의 길이)만큼 반복문을 돌며 탐색중인 workArr의 값이 cache에 있는 어떤 인덱스의 요소와 **값이 같다**면 `Cache Hit`인 상황이므로 해당 **인덱스 값**을 `pos`에 **저장**한다. 
3. 반복문이 끝나고 pos가 -1, 즉, 탐색중인 workArr의 값이 cache의 어느 값하고도 같지 않은(같은 값이 존재하지 않는) `Cache Miss`인 상황이라면 `cache[i] = cache[i - 1]`하여 cache의 각 값들을 현재 인덱스의 **다음 인덱스**로 바꾼다.(값들을 **한 칸씩 뒤로** 밀려나는 상황 구현) 그리고 현재 탐색중인 `workArr`의 값을 cache의 맨 앞, 즉, `cache[0]`의 자리에 넣는다.
4. 만약 `pos`가 -1이 아닌, **인덱스의 값**을 가졌다면 현재 탐색중인 workArr의 값이 cache에 이미 존재하는 `Cache Hit`인 상황이므로 Hit 발생 시점부터 반복문을 시작하여 그 지점부터 cache[1]까지 뒤로 한 칸씩 밀려나도록 한다. 그리고 해당 반복이 끝나면 마찬가지로 cache의 맨 앞 공간에 현재 탐색중인 workArr의 값을 넣는다.

</br>

---

### 🎉 새로 알게된 점은?
삽입정렬이 아니라면 뒤로 미는 방식 말고 unshift() 메서드를 이용해도 좋을 것 같다. 맨 앞 요소를 삭제하는 shift()와는 달리 배열의 맨 앞에 요소를 추가하는 메서드이다. 