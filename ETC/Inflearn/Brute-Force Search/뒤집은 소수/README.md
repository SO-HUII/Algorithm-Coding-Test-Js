## ✍🏻 제목 : 뒤집은 소수
N개의 자연수가 입력되면 각 자연수를 뒤집은 후 그 뒤집은 수가 소수이면 그 소수를 출력하
는 프로그램을 작성하세요. 예를 들어 32를 뒤집으면 23이고, 23은 소수이다. 그러면 23을 출
력한다. 단 910를 뒤집으면 19로 숫자화 해야 한다. 첫 자리부터의 연속된 0은 무시한다.

- `입력조건` : 첫 줄에 자연수의 개수 N(3 <= N <= 100)이 주어지고, 그 다음 줄에 N개의 자연수가 주어진다. 각 자연수의 크기는 100,000를 넘지 않는다.

- `출력조건` : 첫 줄에 뒤집은 소수를 출력합니다. 출력순서는 입력된 순서대로 출력합니다.

|입력예시|출력예시|
|:------:|:----:|
|9</br>32 55 62 20 250 370 200 30 100|23 2 73 2 3|


</br>

---

### 🔍 이렇게 접근 했어요 !

```javascript
for (let i = 0; i < numArr.length; i++) {
        // parseInt()대신 Number()로 해도 됨
        let numReverse = parseInt(numArr[i].toString().split('').reverse().join(''));
        let isPrime = true;

        if (numReverse == 1) {
            isPrime = false;
        } else {
            for (let j = 2; j <= Math.floor(Math.sqrt(numReverse)); j++) {
                if (numReverse % j == 0) {
                    isPrime = false;
                }
            }
        }
        
        // isPrime가 true라면 즉, 소수라면
        if (isPrime) {
            answer += numReverse + " ";
        }
}
```
**>> 소수는 1과 자기 자신만을 약수로 가지는 수이다. 따라서 소수가 아닌 수는 1과 자기 자신 이외의 약수를 가지게 된다. <<** 

숫자의 **뒤집은 수**가 **소수**인지 알아봐야 하는 것이기 때문에 우선 다양한 메서드를 이용하여 현재 탐색중인 수를 

1. `문자열`으로 바꾼 후 

2. 문자열을 각각의 `문자`로 분리하여 `배열`로 만든다. 

3. 배열의 순서를 뒤집어 `역순`으로 만들고

4. 배열의 요소들을 다시 `하나`의 문자열로 결합 (`join('')`)한다.

5. 그리고 4번까지 끝마친 숫자는 문자열 상태이므로 `parseInt()`나 `Number()`를 이용하여 `숫자`로 다시 바꾸어준다.

소수인지 아닌지 boolean값으로 판별하기 위해 `isPrime`을 `true`로 초기화시킨다. 1은 자신 하나이기 때문에 소수가 아니므로 `isPrime` 값이 `false`이고 2이상부터 반복문을 이용해 소수 판별을 해준다. 반복 범위는 해당 수의 **제곱근**까지만 하도록 한다. 

만약 해당 수가 해당 수의 제곱근까지의 수와 하나라도 나누어 떨어진다면 **1**과 **자신**외에 **약수가 있는 것**이니 **소수가 아니다**. 그러므로 이 경우 `isPrime`은 `false` !!


```javascript
let answer=[];
for(let x of arr){
    let res = 0;
    while(x){
        // 숫자 뒤집기	 
        let t = x % 10;  // x의 일의 자리
        res = res * 10 + t;
        x = parseInt(x / 10);
    }
}
```
**다른 방법은 ?!**
해당 계산 과정을 통해 숫자를 뒤집는 방법이 있다. 만약 수가 216이라고 해보자. 반복문이 돌아가며 

1. t = 216 % 10 = 6, res = 0 * 10 + 6 = 6, x = parseInt(216 / 10) = 21

2. t = 21 % 10 = 1, res = 6 * 10 + 1 = 61, x = parseInt(21 / 10) = 2

3. t = 2 % 10 = 2, res = 61 * 10 + 2 = 612, x = parseInt(2 / 10) = 0

이렇게 수를 뒤집어 줄 수 있다.

</br>

---

### 🎉 새로 알게된 점은?
**소수판별시 for문 범위를 제곱근까지만 구하는 이유: 효율성**

예를 들어, 16은 16 = 1 * 16, 2 * 8, 4 * 4와 같은 형태로 약수를 구할 수 있다. 여기서 주목해야 할 것은 16의 제곱근은 `4`. 즉, 4보다 큰 수로 나누어 떨어지는 경우는 이미 4보다 작은 수로도 나누어 떨어지는 경우와 중복된다.(16 * 1, 8 * 2처럼) 따라서 제곱근 이후의 값들은 효율성면에서 확인할 필요가 없다.

</br>

---

### 🐾 회고
소수를 구할때 탐색범위로 제곱근을 왜 사용하나 궁금했는데 드디어 자세히 알게되어서 너무 속이 시원~ ☆*: .｡. o(≧▽≦)o .｡.:*☆ 기본적인 수학지식도 이렇게 활용하려니 어려운 건 왜 일까?ㅎㅎ.. 예시를 하나 선택해 그것으로 식을 해석해 나가는 게 이해에 정말 도움이 되는 것 같다. 